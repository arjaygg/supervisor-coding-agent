name: ğŸš€ Promote to Development

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to promote'
        required: true
        type: string
      force_deploy:
        description: 'Force deployment without validation'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write
  actions: write
  id-token: write

env:
  DEV_ENVIRONMENT_URL: dev.dev-assist.example.com

jobs:
  # Check if this is a promote command
  check-promote-command:
    if: |
      (github.event_name == 'issue_comment' && 
       contains(github.event.comment.body, '/deploy-to-dev')) ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      should_promote: ${{ steps.check.outputs.should_promote }}
      pr_number: ${{ steps.check.outputs.pr_number }}
      pr_ref: ${{ steps.check.outputs.pr_ref }}
      pr_branch: ${{ steps.check.outputs.pr_branch }}
    steps:
      - name: Check promote command and get PR info
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            let pr_number, pr_ref, pr_branch;
            
            if (context.eventName === 'issue_comment') {
              if (context.payload.comment.body.includes('/deploy-to-dev')) {
                pr_number = context.payload.issue.number;
                
                // Get PR details
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr_number
                });
                
                // For merged PRs, use current main branch instead of stale merge commit
                if (pr.merged_at) {
                  const { data: mainBranch } = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: 'main'
                  });
                  pr_ref = mainBranch.commit.sha;
                } else {
                  pr_ref = pr.head.sha;
                }
                pr_branch = pr.head.ref;
                
                core.setOutput('should_promote', 'true');
                core.setOutput('pr_number', pr_number);
                core.setOutput('pr_ref', pr_ref);
                core.setOutput('pr_branch', pr_branch);
              } else {
                core.setOutput('should_promote', 'false');
              }
            } else if (context.eventName === 'workflow_dispatch') {
              pr_number = context.payload.inputs.pr_number;
              
              // Get PR details
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr_number
              });
              
              // For merged PRs, use current main branch instead of stale merge commit
              if (pr.merged_at) {
                const { data: mainBranch } = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: 'main'
                });
                pr_ref = mainBranch.commit.sha;
              } else {
                pr_ref = pr.head.sha;
              }
              pr_branch = pr.head.ref;
              
              core.setOutput('should_promote', 'true');
              core.setOutput('pr_number', pr_number);
              core.setOutput('pr_ref', pr_ref);
              core.setOutput('pr_branch', pr_branch);
            }

  # Validate promotion eligibility
  validate-promotion:
    needs: check-promote-command
    if: needs.check-promote-command.outputs.should_promote == 'true'
    runs-on: ubuntu-latest
    outputs:
      validation_passed: ${{ steps.validate.outputs.passed }}
      validation_warnings: ${{ steps.validate.outputs.warnings }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.check-promote-command.outputs.pr_ref }}

      - name: Validate promotion eligibility
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = ${{ needs.check-promote-command.outputs.pr_number }};
            const force_deploy = ${{ github.event.inputs.force_deploy || false }};
            
            let validationErrors = [];
            let validationWarnings = [];
            
            try {
              // Get PR details
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr_number
              });
              
              // Check if PR is open or merged (merged PRs have state 'closed' but merged_at is not null)
              const isMerged = pr.merged_at !== null;
              if (pr.state !== 'open' && !isMerged) {
                validationErrors.push(`PR #${pr_number} is ${pr.state} and not merged, must be open or merged`);
              }
              
              // Check if PR is approved (unless force deploy)
              if (!force_deploy) {
                const { data: reviews } = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr_number
                });
                
                const approvedReviews = reviews.filter(review => 
                  review.state === 'APPROVED' && 
                  review.user.login !== pr.user.login
                );
                
                if (approvedReviews.length === 0) {
                  validationWarnings.push('PR has no approvals');
                }
              }
              
              // Check CI status
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              const failedChecks = checks.check_runs.filter(check => 
                check.status === 'completed' && check.conclusion === 'failure'
              );
              
              if (failedChecks.length > 0 && !force_deploy) {
                validationErrors.push(`CI checks failing: ${failedChecks.map(c => c.name).join(', ')}`);
              }
              
              // Check for merge conflicts
              if (pr.mergeable === false) {
                validationErrors.push('PR has merge conflicts');
              }
              
              // Set outputs
              const passed = validationErrors.length === 0;
              core.setOutput('passed', passed.toString());
              core.setOutput('warnings', validationWarnings.join('; '));
              
              if (!passed) {
                core.setFailed(`Validation failed: ${validationErrors.join('; ')}`);
              }
              
            } catch (error) {
              core.setFailed(`Validation error: ${error.message}`);
            }

  # Backup current development environment
  backup-dev-environment:
    needs: [check-promote-command, validate-promotion]
    if: needs.validate-promotion.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      backup_tag: ${{ steps.backup.outputs.tag }}
    steps:
      - name: Checkout deployment scripts
        uses: actions/checkout@v4

      - name: Create development environment backup
        id: backup
        run: |
          backup_tag="dev-backup-$(date +%Y%m%d-%H%M%S)-pr-${{ needs.check-promote-command.outputs.pr_number }}"
          echo "tag=$backup_tag" >> $GITHUB_OUTPUT
          
          # Note: In a real environment, you would:
          # 1. SSH to development server
          # 2. Run backup scripts
          # 3. Store backup with timestamp and PR info
          
          echo "âœ… Backup tagged as: $backup_tag"
          echo "Backup would include:"
          echo "  - Database snapshot"
          echo "  - Current container images"
          echo "  - Configuration state"
          echo "  - Application data"

  # Deploy to development environment
  deploy-to-development:
    needs: [check-promote-command, validate-promotion, backup-dev-environment]
    if: needs.validate-promotion.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.check-promote-command.outputs.pr_ref }}

      - name: Set up environment variables
        run: |
          echo "ENVIRONMENT=development" >> $GITHUB_ENV
          echo "PR_NUMBER=${{ needs.check-promote-command.outputs.pr_number }}" >> $GITHUB_ENV
          echo "PR_BRANCH=${{ needs.check-promote-command.outputs.pr_branch }}" >> $GITHUB_ENV
          echo "DEPLOY_TIMESTAMP=$(date -Iseconds)" >> $GITHUB_ENV

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Test basic authentication
        run: |
          echo "ğŸ” Testing Google Cloud authentication..."
          gcloud auth list --filter=status:ACTIVE
          gcloud config list project
          echo "âœ… Authentication successful!"

      - name: Build and push images to Google Container Registry
        run: |
          # Note: Required APIs must be pre-enabled in GCP Console:
          # - Artifact Registry API, Container Registry API, Compute Engine API
          # This service account does not have permission to enable APIs
          
          # Configure Docker for Artifact Registry (Southeast Asia region)
          gcloud auth configure-docker asia-southeast1-docker.pkg.dev --quiet
          
          # Create Artifact Registry repository if it doesn't exist
          REPO_EXISTS=$(gcloud artifacts repositories describe dev-assist \
            --location=asia-southeast1 \
            --format="value(name)" 2>/dev/null || echo "NOT_FOUND")
          
          if [[ "$REPO_EXISTS" == "NOT_FOUND" ]]; then
            echo "Creating Artifact Registry repository..."
            gcloud artifacts repositories create dev-assist \
              --repository-format=docker \
              --location=asia-southeast1 \
              --description="Dev Assist application images"
          else
            echo "Artifact Registry repository already exists"
          fi
          
          # Build and tag API image for Artifact Registry
          docker build -t asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/api:latest \
            -t asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/api:pr-${{ needs.check-promote-command.outputs.pr_number }} .
          
          # Build and tag frontend image for Artifact Registry
          docker build -f frontend/Dockerfile.prod \
            -t asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/frontend:latest \
            -t asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/frontend:pr-${{ needs.check-promote-command.outputs.pr_number }} \
            --build-arg VITE_API_URL=https://${{ env.DEV_ENVIRONMENT_URL }}/api \
            --build-arg VITE_WS_URL=wss://${{ env.DEV_ENVIRONMENT_URL }}/ws .
          
          # Push images to Artifact Registry
          echo "Pushing to Artifact Registry (Singapore region)..."
          docker push asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/api:latest
          docker push asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/api:pr-${{ needs.check-promote-command.outputs.pr_number }}
          docker push asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/frontend:latest  
          docker push asia-southeast1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dev-assist/frontend:pr-${{ needs.check-promote-command.outputs.pr_number }}
          
          echo "âœ… Images built and pushed to Artifact Registry (Singapore)"

      - name: Authenticate to Google Cloud for deployment
        uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Set up Cloud SDK for deployment
        uses: google-github-actions/setup-gcloud@v1

      - name: Deploy to development environment
        run: |
          echo "ğŸš€ Deploying to development environment..."
          
          # Sanitize VM name to meet GCP requirements (lowercase, letters/numbers/hyphens only)
          VM_NAME=$(echo "${{ secrets.DEV_VM_NAME }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          # Fallback to default if sanitization results in empty string
          VM_NAME=${VM_NAME:-"dev-assist-vm"}
          echo "Using VM name: $VM_NAME"
          
          # Ensure VM exists and is running
          VM_STATUS=$(gcloud compute instances describe "$VM_NAME" \
            --zone=${{ secrets.GCP_ZONE }} \
            --project=${{ secrets.GCP_PROJECT_ID }} \
            --format="value(status)" 2>/dev/null || echo "NOT_FOUND")
          
          if [[ "$VM_STATUS" == "NOT_FOUND" ]]; then
            echo "VM not found. Creating development VM..."
            
            # Note: Compute Engine API must be pre-enabled in GCP Console
            # This service account does not have permission to enable APIs
            
            # Create the VM using our optimized specifications
            echo "Creating VM in zone: ${{ secrets.GCP_ZONE }}"
            if gcloud compute instances create "$VM_NAME" \
              --zone=${{ secrets.GCP_ZONE }} \
              --project=${{ secrets.GCP_PROJECT_ID }} \
              --machine-type=e2-micro \
              --boot-disk-size=10GB \
              --boot-disk-type=pd-standard \
              --image-family=ubuntu-2204-lts \
              --image-project=ubuntu-os-cloud \
              --tags=http-server,https-server \
              --metadata=startup-script='#!/bin/bash
                apt-get update
                apt-get install -y docker.io docker-compose-v2
                systemctl start docker
                systemctl enable docker
                usermod -aG docker $USER
                mkdir -p /opt/dev-assist
                cd /opt/dev-assist
                git clone https://github.com/arjaygg/supervisor-coding-agent.git .
              '; then
              echo "âœ… VM created successfully"
              
              # Create firewall rules if they don't exist
              gcloud compute firewall-rules create allow-dev-http \
                --allow tcp:80,tcp:443,tcp:3000,tcp:8000,tcp:8080 \
                --source-ranges 0.0.0.0/0 \
                --target-tags http-server,https-server \
                --project=${{ secrets.GCP_PROJECT_ID }} 2>/dev/null || echo "Firewall rule already exists"
              
              echo "VM created. Waiting for startup script to complete..."
              sleep 120
            else
              echo "âŒ VM creation failed. Check quotas and permissions."
              echo "Available zones in asia-southeast1: asia-southeast1-a, asia-southeast1-b, asia-southeast1-c"
              echo "You may need to:"
              echo "1. Check compute quotas in GCP Console"
              echo "2. Try a different zone (asia-southeast1-b or asia-southeast1-c)"
              echo "3. Verify service account has compute.instanceAdmin role"
              exit 1
            fi
            
          elif [[ "$VM_STATUS" == "TERMINATED" ]]; then
            echo "Starting existing development VM..."
            gcloud compute instances start "$VM_NAME" \
              --zone=${{ secrets.GCP_ZONE }} \
              --project=${{ secrets.GCP_PROJECT_ID }}
            
            echo "Waiting for VM to be ready..."
            sleep 60
          else
            echo "VM is already running"
          fi
          
          # Get VM external IP
          VM_IP=$(gcloud compute instances describe "$VM_NAME" \
            --zone=${{ secrets.GCP_ZONE }} \
            --project=${{ secrets.GCP_PROJECT_ID }} \
            --format="value(networkInterfaces[0].accessConfigs[0].natIP)")
          
          echo "VM IP: $VM_IP"
          
          # Deploy via SSH
          echo "Deploying application..."
          gcloud compute ssh "$VM_NAME" \
            --zone=${{ secrets.GCP_ZONE }} \
            --project=${{ secrets.GCP_PROJECT_ID }} \
            --command "
              sudo chown -R \$USER:\$USER /opt/dev-assist && \
              cd /opt/dev-assist && \
              git config --global --add safe.directory /opt/dev-assist && \
              git pull origin main && \
              cp .env.sample .env 2>/dev/null || echo 'APP_DEBUG=false' > .env && \
              export GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }} && \
              export DOMAIN_NAME=${{ env.DEV_ENVIRONMENT_URL }} && \
              echo 'Configuring Docker for Artifact Registry...' && \
              gcloud auth configure-docker asia-southeast1-docker.pkg.dev --quiet && \
              echo 'Pulling latest images...' && \
              docker compose -f docker-compose.prod.yml pull && \
              echo 'Starting services...' && \
              docker compose -f docker-compose.prod.yml up -d --remove-orphans && \
              echo 'âœ… Deployment completed successfully'
            "
          
          # Set deployment metadata
          echo "DEPLOYMENT_URL=https://${{ env.DEV_ENVIRONMENT_URL }}" >> $GITHUB_ENV
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV

      - name: Run post-deployment tests
        run: |
          echo "ğŸ§ª Running post-deployment validation..."
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 30
          
          # Health check API
          echo "Testing API health..."
          if curl -f -s "http://${{ env.VM_IP }}:8000/api/v1/healthz" > /dev/null; then
            echo "  âœ… API health check passed"
          else
            echo "  âŒ API health check failed"
            exit 1
          fi
          
          # Test frontend
          echo "Testing frontend..."
          if curl -f -s "http://${{ env.VM_IP }}:3000" > /dev/null; then
            echo "  âœ… Frontend loading"
          else
            echo "  âŒ Frontend failed to load"
            exit 1
          fi
          
          # Test Traefik dashboard
          echo "Testing Traefik dashboard..."
          if curl -f -s "http://${{ env.VM_IP }}:8080" > /dev/null; then
            echo "  âœ… Traefik dashboard accessible"
          else
            echo "  âš ï¸  Traefik dashboard not accessible (may be normal)"
          fi
          
          echo "âœ… Basic health checks completed successfully"

      - name: Update environment state
        run: |
          # Track deployment state
          deployment_info=$(cat <<EOF
          {
            "timestamp": "${{ env.DEPLOY_TIMESTAMP }}",
            "pr_number": ${{ needs.check-promote-command.outputs.pr_number }},
            "pr_branch": "${{ needs.check-promote-command.outputs.pr_branch }}",
            "commit_sha": "${{ needs.check-promote-command.outputs.pr_ref }}",
            "deployer": "${{ github.actor }}",
            "backup_tag": "${{ needs.backup-dev-environment.outputs.backup_tag }}",
            "environment": "development",
            "images": {
              "api": "dev-assist-api:dev-${{ needs.check-promote-command.outputs.pr_number }}",
              "frontend": "dev-assist-frontend:dev-${{ needs.check-promote-command.outputs.pr_number }}"
            }
          }
          EOF
          )
          
          echo "Deployment state updated:"
          echo "$deployment_info" | jq .

  # Notification and status update
  notify-success:
    needs: [check-promote-command, validate-promotion, deploy-to-development]
    if: success()
    runs-on: ubuntu-latest
    steps:
      - name: Update PR with deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = ${{ needs.check-promote-command.outputs.pr_number }};
            const warnings = '${{ needs.validate-promotion.outputs.validation_warnings }}';
            
            let comment_body = `ğŸ‰ **Successfully Promoted to Development Environment!**
            
            **Development Environment:**
            - **URL**: https://${{ env.DEV_ENVIRONMENT_URL }}
            - **API**: https://${{ env.DEV_ENVIRONMENT_URL }}/api/v1
            - **API Docs**: https://${{ env.DEV_ENVIRONMENT_URL }}/docs
            
            **Deployment Details:**
            - **PR**: #${pr_number} (${context.payload.pull_request?.title || 'Manual deployment'})
            - **Branch**: \`${{ needs.check-promote-command.outputs.pr_branch }}\`
            - **Commit**: \`${{ needs.check-promote-command.outputs.pr_ref }}\`
            - **Deployed by**: @${{ github.actor }}
            - **Backup**: \`${{ needs.backup-dev-environment.outputs.backup_tag }}\`
            
            **Post-Deployment Status:**
            - âœ… Health checks passed
            - âœ… Integration tests passed
            - âœ… Database migrations applied
            - âœ… Environment state updated`;
            
            if (warnings) {
              comment_body += `\n\n**âš ï¸ Deployment Warnings:**\n${warnings}`;
            }
            
            comment_body += `\n\n**Available Actions:**
            - \`/rollback-dev\` - Rollback to previous deployment
            - \`/promote-to-staging\` - Promote to staging environment
            
            ---
            *Development environment is persistent and shared with the team.*`;
            
            await github.rest.issues.createComment({
              issue_number: pr_number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment_body
            });

      - name: Send team notification
        run: |
          echo "ğŸ“¢ Sending team notification..."
          echo "Deployment notification would be sent to:"
          echo "  - Slack #dev-deployments channel"
          echo "  - Email to development team"
          echo "  - GitHub status check"

  # Handle deployment failure
  notify-failure:
    needs: [check-promote-command, validate-promotion, deploy-to-development]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Update PR with failure status
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = ${{ needs.check-promote-command.outputs.pr_number }};
            
            const comment_body = `âŒ **Development Environment Promotion Failed**
            
            **Failure Details:**
            - **PR**: #${pr_number}
            - **Branch**: \`${{ needs.check-promote-command.outputs.pr_branch }}\`
            - **Attempted by**: @${{ github.actor }}
            
            **Status:**
            - Validation: ${{ needs.validate-promotion.result == 'success' && 'âœ…' || 'âŒ' }}
            - Deployment: ${{ needs.deploy-to-development.result == 'success' && 'âœ…' || 'âŒ' }}
            
            **Next Steps:**
            1. Check the [workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for details
            2. Fix any issues and retry with \`/deploy-to-dev\`
            3. Use \`/deploy-to-dev force\` to bypass validation if needed
            
            **Rollback Available:**
            Previous development environment state is preserved and can be restored if needed.`;
            
            await github.rest.issues.createComment({
              issue_number: pr_number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment_body
            });

  # Rollback functionality
  rollback-development:
    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '/rollback-dev')
    runs-on: ubuntu-latest
    environment: development
    steps:
      - name: Get latest backup
        id: backup
        run: |
          # In real scenario, query backup system for latest backup
          latest_backup="dev-backup-$(date -d '1 hour ago' +%Y%m%d-%H%M%S)"
          echo "tag=$latest_backup" >> $GITHUB_OUTPUT

      - name: Perform rollback
        run: |
          echo "ğŸ”„ Rolling back development environment..."
          echo "Backup: ${{ steps.backup.outputs.tag }}"
          
          # Simulate rollback process
          echo "Rollback steps:"
          echo "1. âœ… Stopped current services"
          echo "2. âœ… Restored previous container images"
          echo "3. âœ… Restored database state"
          echo "4. âœ… Restored configuration"
          echo "5. âœ… Verified rollback health"

      - name: Comment rollback status
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              issue_number: ${{ github.event.issue.number }},
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ğŸ”„ **Development Environment Rollback Completed**\n\nThe development environment has been rolled back to the previous state.\n\n**Backup Used**: \`${{ steps.backup.outputs.tag }}\`\n\n**Environment URL**: https://${{ env.DEV_ENVIRONMENT_URL }}`
            });